#include "gemm_kernels.h"

const char *oclSGEMM =
    "\n"
    "__kernel void sgemm(const int colMajor, const int transa, const int transb,\n"
    "		const unsigned int m, const unsigned int n, const unsigned int k,\n"
    "		const float alpha, __global float* a, const int lda, __global float* b,\n"
    "		const int ldb, const float beta, __global float* c, const int ldc)\n"
    "{\n"
    "	__local float bufferA[SUBMATRIX_SIZE * SUBMATRIX_SIZE];\n"
    "	__local\n"
    "	float bufferB[SUBMATRIX_SIZE * SUBMATRIX_SIZE];\n"
    "\n"
    "	const int row = get_global_id(0);\n"
    "	const int col = get_global_id(1);\n"
    "\n"
    "	const int localRow = get_local_id(0);\n"
    "	const int localCol = get_local_id(1);\n"
    "\n"
    "	const int transc = 0;\n"
    "	FloatMatrix A =\n"
    "	{ m, k, colMajor, transa, lda, a };\n"
    "	FloatMatrix B =\n"
    "	{ k, n, colMajor, transb, ldb, b };\n"
    "	FloatMatrix C =\n"
    "	{ m, n, colMajor, transc, ldc, c };\n"
    "\n"
    "	float r = 0.0;\n"
    "	for (int i = 0; i < k; i += SUBMATRIX_SIZE)\n"
    "	{\n"
    "		bufferA[localCol * SUBMATRIX_SIZE + localRow] = getMatrixFloat(A, row,\n"
    "				i + localCol);\n"
    "		bufferB[localCol * SUBMATRIX_SIZE + localRow] = getMatrixFloat(B, i\n"
    "				+ localRow, col);\n"
    "\n"
    "		/*\n"
    "		 * Synchronize to make sure the sub-matrices are loaded\n"
    "		 * before starting the computation\n"
    "		 */\n"
    "		barrier(CLK_LOCAL_MEM_FENCE);\n"
    "\n"
    "		for (int j = 0; j < SUBMATRIX_SIZE; ++j)\n"
    "		{\n"
    "			r += bufferA[j * SUBMATRIX_SIZE + localRow] * bufferB[localCol\n"
    "					* SUBMATRIX_SIZE + j];\n"
    "		}\n"
    "\n"
    "		/*\n"
    "		 * Synchronize to make sure that the preceding\n"
    "		 * computation is done before loading two new\n"
    "		 * sub-matrices of A and B in the next iteration\n"
    "		 */\n"
    "		barrier(CLK_LOCAL_MEM_FENCE);\n"
    "	}\n"
    "\n"
    "	if (beta == 0.0)\n"
    "	{\n"
    "		setMatrixFloat(C, row, col, alpha * r);\n"
    "	}\n"
    "	else\n"
    "	{\n"
    "		setMatrixFloat(C, row, col, alpha * r + beta * getMatrixFloat(C, row,\n"
    "				col));\n"
    "	}\n"
    "}\n";

const char *oclDGEMM =
    "\n"
    "__kernel void sgemm(const int colMajor, const int transa, const int transb,\n"
    "		const unsigned int m, const unsigned int n, const unsigned int k,\n"
    "		const double alpha, __global double* a, const int lda,\n"
    "		__global double* b, const int ldb, const double beta,\n"
    "		__global double* c, const int ldc)\n"
    "{\n"
    "	__local double bufferA[SUBMATRIX_SIZE * SUBMATRIX_SIZE];\n"
    "	__local\n"
    "	double bufferB[SUBMATRIX_SIZE * SUBMATRIX_SIZE];\n"
    "\n"
    "	const int row = get_global_id(0);\n"
    "	const int col = get_global_id(1);\n"
    "\n"
    "	const int localRow = get_local_id(0);\n"
    "	const int localCol = get_local_id(1);\n"
    "\n"
    "	const int transc = 0;\n"
    "	FloatMatrix A =\n"
    "	{ m, k, colMajor, transa, lda, a };\n"
    "	FloatMatrix B =\n"
    "	{ k, n, colMajor, transb, ldb, b };\n"
    "	FloatMatrix C =\n"
    "	{ m, n, colMajor, transc, ldc, c };\n"
    "\n"
    "	double r = 0.0;\n"
    "	for (int i = 0; i < k; i += SUBMATRIX_SIZE)\n"
    "	{\n"
    "		bufferA[localCol * SUBMATRIX_SIZE + localRow] = getMatrixFloat(A, row,\n"
    "				i + localCol);\n"
    "		bufferB[localCol * SUBMATRIX_SIZE + localRow] = getMatrixFloat(B, i\n"
    "				+ localRow, col);\n"
    "\n"
    "		/*\n"
    "		 * Synchronize to make sure the sub-matrices are loaded\n"
    "		 * before starting the computation\n"
    "		 */\n"
    "		barrier(CLK_LOCAL_MEM_FENCE);\n"
    "\n"
    "		for (int j = 0; j < SUBMATRIX_SIZE; ++j)\n"
    "		{\n"
    "			r += bufferA[j * SUBMATRIX_SIZE + localRow] * bufferB[localCol\n"
    "					* SUBMATRIX_SIZE + j];\n"
    "		}\n"
    "\n"
    "		/*\n"
    "		 * Synchronize to make sure that the preceding\n"
    "		 * computation is done before loading two new\n"
    "		 * sub-matrices of A and B in the next iteration\n"
    "		 */\n"
    "		barrier(CLK_LOCAL_MEM_FENCE);\n"
    "	}\n"
    "\n"
    "	if (beta == 0.0)\n"
    "	{\n"
    "		setMatrixFloat(C, row, col, alpha * r);\n"
    "	}\n"
    "	else\n"
    "	{\n"
    "		setMatrixFloat(C, row, col, alpha * r + beta * getMatrixFloat(C, row,\n"
    "				col));\n"
    "	}\n"
    "}\n";
