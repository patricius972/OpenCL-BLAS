/*
 * sgemm_cl.c
 *
 *  Created on: Apr 22, 2011
 *      Author: ludwig
 */

#include "gemm_kernels.h"

const char *opencl_sgemm_kernel = ""
	"__kernel void sgemm(const int colMajor,                              \n"
	"                    const int transa,                                \n"
	"                    const int transb,                                \n"
	"                    const unsigned int m,                            \n"
	"                    const unsigned int n,                            \n"
	"                    const unsigned int k,                            \n"
	"                    const float alpha,                               \n"
	"                    __global float* a,                               \n"
	"                    const int lda,                                   \n"
	"                    __global float* b,                               \n"
	"                    const int ldb,                                   \n"
	"                    const float beta,                                \n"
	"                    __global float* c,                               \n"
	"                    const int ldc)                                   \n"
	"{                                                                    \n"
	"    __local float bufferA[SUBMATRIX_SIZE * SUBMATRIX_SIZE];          \n"
	"    __local float bufferB[SUBMATRIX_SIZE * SUBMATRIX_SIZE];          \n"
	"                                                                     \n"
	"    const int row = get_global_id(0);                                \n"
	"    const int col = get_global_id(1);                                \n"
	"                                                                     \n"
	"    const int localRow = get_local_id(0);                            \n"
	"    const int localCol = get_local_id(1);                            \n"
	"                                                                     \n"
	"    const int transc = 0;                                            \n"
	"    FloatMatrix A = {m, k, colMajor, transa, lda, a};                \n"
	"    FloatMatrix B = {k, n, colMajor, transb, ldb, b};                \n"
	"    FloatMatrix C = {m, n, colMajor, transc, ldc, c};                \n"
	"                                                                     \n"
	"    float r = 0.0;                                                   \n"
	"    for (int i = 0; i < k; i += SUBMATRIX_SIZE)                      \n"
	"    {                                                                \n"
	"        bufferA[localCol * SUBMATRIX_SIZE + localRow] =              \n"
	"            getMatrixFloat(A, row, i + localCol);                    \n"
	"        bufferB[localCol * SUBMATRIX_SIZE + localRow] =              \n"
	"            getMatrixFloat(B, i + localRow, col);                    \n"
	"                                                                     \n"
	"		 // Synchronize to make sure the sub-matrices are loaded      \n"
	"		 // before starting the computation                           \n"
	"		 barrier(CLK_LOCAL_MEM_FENCE);                                \n"
	"                                                                     \n"
	"        #pragma unroll                                               \n"
	"        for (int j = 0; j < SUBMATRIX_SIZE; ++j)                     \n"
	"        {                                                            \n"
	"            r += bufferA[j * SUBMATRIX_SIZE + localRow]              \n"
	"               * bufferB[localCol * SUBMATRIX_SIZE + j];             \n"
	"        }                                                            \n"
	"                                                                     \n"
	"		 // Synchronize to make sure that the preceding               \n"
	"		 // computation is done before loading two new                \n"
	"		 // sub-matrices of A and B in the next iteration             \n"
	"		 barrier(CLK_LOCAL_MEM_FENCE);                                \n"
	"    }                                                                \n"
	"                                                                     \n"
	"    if (beta == 0.0)                                                 \n"
	"    {                                                                \n"
	"        setMatrixFloat(C, row, col, alpha * r);                      \n"
	"    }                                                                \n"
	"    else                                                             \n"
	"    {                                                                \n"
	"        setMatrixFloat(C, row, col,                                  \n"
	"                alpha * r + beta * getMatrixFloat(C, row, col));     \n"
	"    }                                                                \n"
	"}                                                                    \n";

const char *opencl_dgemm_kernel = ""
#if OCL_DOUBLE_SUPPORTED == 1
		"__kernel void sgemm(const int colMajor,                          \n"
		"                    const int transa,                            \n"
		"                    const int transb,                            \n"
		"                    const unsigned int m,                        \n"
		"                    const unsigned int n,                        \n"
		"                    const unsigned int k,                        \n"
		"                    const double alpha,                          \n"
		"                    __global double* a,                          \n"
		"                    const int lda,                               \n"
		"                    __global double* b,                          \n"
		"                    const int ldb,                               \n"
		"                    const double beta,                           \n"
		"                    __global double* c,                          \n"
		"                    const int ldc)                               \n"
		"{                                                                \n"
		"    __local double bufferA[SUBMATRIX_SIZE * SUBMATRIX_SIZE];     \n"
		"    __local double bufferB[SUBMATRIX_SIZE * SUBMATRIX_SIZE];     \n"
		"                                                                 \n"
		"    const int row = get_global_id(0);                            \n"
		"    const int col = get_global_id(1);                            \n"
		"                                                                 \n"
		"    const int localRow = get_local_id(0);                        \n"
		"    const int localCol = get_local_id(1);                        \n"
		"                                                                 \n"
		"    const int transc = 0;                                        \n"
		"    DoubleMatrix A = {m, k, colMajor, transa, lda, a};           \n"
		"    DoubleMatrix B = {k, n, colMajor, transb, ldb, b};           \n"
		"    DoubleMatrix C = {m, n, colMajor, transc, ldc, c};           \n"
		"                                                                 \n"
		"    double r = 0.0;                                              \n"
		"    for (int i = 0; i < k; i += SUBMATRIX_SIZE)                  \n"
		"    {                                                            \n"
		"        bufferA[localCol * SUBMATRIX_SIZE + localRow] =          \n"
		"            getMatrixFloat(A, row, i + localCol);                \n"
		"        bufferB[localCol * SUBMATRIX_SIZE + localRow] =          \n"
		"            getMatrixFloat(B, i + localRow, col);                \n"
		"                                                                 \n"
		"		 // Synchronize to make sure the sub-matrices are loaded  \n"
		"		 // before starting the computation                       \n"
		"		 barrier(CLK_LOCAL_MEM_FENCE);                            \n"
		"                                                                 \n"
		"        #pragma unroll                                           \n"
		"        for (int j = 0; j < SUBMATRIX_SIZE; ++j)                 \n"
		"        {                                                        \n"
		"            r += bufferA[j * SUBMATRIX_SIZE + localRow]          \n"
		"               * bufferB[localCol * SUBMATRIX_SIZE + j];         \n"
		"        }                                                        \n"
		"                                                                 \n"
		"		 // Synchronize to make sure that the preceding           \n"
		"		 // computation is done before loading two new            \n"
		"		 // sub-matrices of A and B in the next iteration         \n"
		"		 barrier(CLK_LOCAL_MEM_FENCE);                            \n"
		"    }                                                            \n"
		"                                                                 \n"
		"    if (beta == 0.0)                                             \n"
		"    {                                                            \n"
		"        setMatrixFloat(C, row, col, alpha * r);                  \n"
		"    }                                                            \n"
		"    else                                                         \n"
		"    {                                                            \n"
		"        setMatrixFloat(C, row, col,                              \n"
		"                alpha * r + beta * getMatrixFloat(C, row, col)); \n"
		"    }                                                            \n"
		"}                                                                \n"
#endif
			"                                                             \n";
